# 第六周

## 动态规划解题方式：
1. 找到最近最简方法，将其拆解成可重复解决的问题
2. 数学归纳法思维
- 动态规划和递归或分治没有本质上的区别
- 共性：找到重复子问题
- 差异性：最优子结构、中途可以淘汰次优解


## 斐波那契数列
暴力递归（傻递归）时间复杂度是O(2^n)
找到状态转移方程 :F(n) = F(n - 1) + F(n - 2)
```java

a[0] = 0, a[1] = 1;
for (int i = 2; i <= n; ++i) {
    a[i] = a[i - 1] + a[i - 2];
}

```

## 动态规划关键点
1. 最优子结构 opt[n] = best_of(opt[n - 1], opt[n - 2],...) ，通常best_of是求最大值或最小值
2. 存储中间状态：opt[i]
3. 递推公式/状态转移方程
        Fib : opt[i] = opt[n - 1] + opt[n - 2]
        二维路径：opt[i, j] = opt[i + 1][j] + opt[i][j + 1] (并且判断a[i][j]是否是空地)
        

爬楼梯问题
dp方程组 dp[i] = dp[i - 1] + dp[i - 2];  dp[0] = 1; dp[1] = 2;
可以使用两个变量去记录当前楼梯层下层，及下下层的值
优化后的代码如下：
```java
public int climbStairs(int n) {
    if (n == 0) {
      return 0;
    }
    if (n == 1) {
      return 1;
    }
    int n_1 = 1;
    int n_2 = 2;
    int result = n_2;
    for (int i = 2; i < n; i++) {
      result =n_1 + n_2;
      n_1 = n_2;
      n_2 = result;
    }
    return result;
}
```
1. 爬楼梯变种问题，每次可爬楼层1，2，3
    
   dp方程组就应该是dp[n] = dp[n - 1] + dp[n - 2] + dp[n - 3]
   
2. 爬楼梯变种问题2，相邻两步不相同

   分析第一层走一步1可以到达，
   第二层只能走2步，一次到达
   第三层可以一次走3步，或者1，2，或者2，1， 3次到达
   第四层3，1；1，3；1，2，1； 3次到达
   没任何规律。。。看不懂
   换位思考：
       需要记录上一步走的几步，比如第四层，记录dp[3][1],上到第四层上一步走了1步，
       dp[3][2],上到第四层上一步走了2步，
       dp[3][3],上到第四层上一步走了3步。
  代码如下，结果写了几个测试用例测试有问题。。。暂且留着吧
 ```java
public int climbStairs(int n) {
    if (n == 0) {
      return 0;
    }
    if (n == 1) {
      return 1;
    }
    if (n == 2) {
      return 1;
    }
    int[][] dp = new int[n][3];
    dp[0][0] = 1; // 第一层走一步
    dp[0][1] = 0;
    dp[0][2] = 0;
    dp[1][0] = 0;
    dp[1][1] = 1;// 第二层走两步
    dp[1][2] = 0;
    dp[2][0] = dp[1][1] + dp[1][2];// 2, 1
    dp[2][1] = dp[1][0] + dp[1][2];// 1, 2
    dp[2][2] = dp[1][0] + dp[1][1] + 1; // 0, 3
    for (int i = 3; i < n; i++) {
      dp[i][0] = dp[i - 1][1] + dp[i - 1][2];
      dp[i][1] = dp[i - 1][0] + dp[i - 1][2];
      dp[i][2] = dp[i - 1][0] + dp[i - 1][1];
    }
    return dp[n - 1][0] + dp[n - 1][1] + dp[n - 1][2];
  }
```

